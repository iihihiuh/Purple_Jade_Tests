// Compute factorial recursively with an iterative sum
// - Input taken from R0
// - Result returned in R2

MOVS R0, 7 // 0 Load the factorial input to R0
MOVS R1, 1 // 1 R1 stores the comparator value
MOV R2, R0 // 2 R2 stores the accumulated product
CMP R0, R1 // 3 Exit if input is <= 1
BLE END    // 4 ...
NOOP       // 5 ...
MOVS R3, 1 // 6 Initialize the ITER_PROD counter (current multiplier)
// Recursive product to compute factorial
ITER_PROD: MOV R4, R2     // 7
           MOVS R5, 1     // 8 Initialize the ITER_SUM counter (current multiplicand)
           BL ITER_SUM    // 9 Compute the product
           NOOP           // 10 ...
           ADDS R3, R3, 1 // 11 Increment the ITER_PROD counter
           CMP R3, R0     // 12 Finish if we have performed all of the products
           BNE ITER_PROD  // 13 ...
           NOOP           // 14 ...
           B END          // 15 ...
           NOOP           // 16 ...
// Recursive summation to compute a product
ITER_SUM: MOV R6, R14     // 17 Save the LR on the stack
          MOV R7, R13     // 18 ...
          STR R6, [R7, 0] // 19 ...
          SUB SP, SP, 1   // 20 ...
          CMP R3, R1      // 21 If the multiplier is 1, return
          BEQ RETURN      // 22 ...
          NOOP            // 23 ...
          SUBS R6, R3, 1  // 24 Else if the product is finished, accumulate it on R2
          CMP R6, R5      // 25 ...
          BEQ ACCUMULATE  // 26 ...
          NOOP            // 27 ...
          ADDS R5, R5, 1  // 28 Else increment the ITER_SUM counter and recurse
          BL ITER_SUM     // 29 ...
          NOOP            // 30 ...
// Accumulate the computed product on R2
ACCUMULATE: ADDS R2, R2, R4 // 31
// Return to either line15, or to line36
RETURN: ADD SP, SP, 1       // 32 Pop LR off stack and branch
MOV R7, R13                 // 33 ...
LDR R6, [R7, 0]             // 34 ...
BX R6                       // 35 ...
// Finish!
END: NOOP                   // 36
MOV R2, R2                  // 37 Makes viewing the result convenient
